# -*- coding: utf-8 -*-
"""Copy of tasks1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qkDzRTwgPy-i_X6kcfHDKe5oIg_1aB1B

# Computer Vision Assignments: Sessions 1 & 2

This notebook contains tasks and assignments based on Sessions 1 and 2. You are required to implement the functions and complete the exercises as described. Use OpenCV and other necessary libraries like NumPy and Matplotlib.

**Instructions:**
- Complete each task in the provided code cells.
- Test your implementations with sample images (e.g., download test images [here](https://sipi.usc.edu/database/database.php?volume=misc) or [here](https://www.hlevkin.com/hlevkin/06testimages.htm) or use your own test images).
- Include comments in your code for clarity.
- Display results using cv2.imshow() or Matplotlib where appropriate.
- Submit the completed notebook along with any output images or explanations on [our google drive for the CV sessions](https://drive.google.com/drive/folders/1IjVhJmAXxNQTGT-ybJ-yc5smYtR5v8CO?usp=sharing) **upload your files in a new folder under your name**

## Session 1: Basic Image Operations (Reading, Resizing, Cropping, Rotating)

### Task 1: Read and Display an Image
Read an image from a file and display it in both BGR and grayscale formats. Handle errors if the image cannot be read.
"""

# Commented out IPython magic to ensure Python compatibility.
import cv2 as cv
import numpy as np
import sys
import matplotlib.pyplot as plt
# %matplotlib inline

# Your code here

#the following code is for loading the image after it is uploaded manually
uploaded=files.upload() #upload the file
filename=list(uploaded.Keys())[0] #get the first uploaded image's name

# Read in BGR
imgbgr=cv.imread(filename,-1)
assert imgbgr is not None, "can't read bgr image"
# Read in Grayscale
imggray=cv.imread(filename,0)
assert imggray is not None, "can't read gray image"
# Display both using cv.imshow() or plt.imshow()
cv.imshow("normal",imgbgr)
k=cv.waitkey(0)
cv.destroyAllwindows()
cv.imshow("gray",imggray)
k=cv.waitkey(0)
cv.destroyAllwindows()



"""### Task 2: Resize Image with Aspect Ratio Preservation
Implement resizing while preserving aspect ratio. Downscale to 60% and upscale to 200%. Compare shapes and display originals vs resized.
"""

# Your code here
# Load image
imgbgr=cv.imread(filename,-1)
# Downscale to 60%
scale_percent=60
h,w,_=imgbgr.shape
h=int(scale_percent*h/100)
w=int(scale_percent*w/100)
dim=(h,w)
down_img=cv.resize(imgbgr,dim,interpolation=cv.INTER_AREA)
# Upscale to 200%
scale_percent=200
h,w,_=imgbgr.shape
h=int(scale_percent*h/100)
w=int(scale_percent*w/100)
dim=(h,w)
up_img=cv.resize(imgbgr,dim,interpolation=cv.INTER_AREA)
# Display all three
cv.imshow("original",imgbgr)
cv.waitkey(0)
cv.imshow("up-scaled",up_img)
cv.waitkey(0)
cv.imshow("down-scaled",down_img)
cv.waitkey(0)
cv.destroyAllwindows()

"""### Task 3: Resize Without Preserving Aspect Ratio
Resize only width to 100 pixels, only height to 200 pixels, and both to (200, 200). Display and discuss distortions.
"""

# Your code here
#width to 100 pixels
h,w,_=imgbgr.shape
h=h
w=100
dim=(h,w)
width_img=cv.resize(imgbgr,dim,interpolation=cv.INTER_AREA)
cv.imshow("original".imgbgr)
cv.waitkey(0)
cv.imshow("width image",width_img)
cv.waitkey(0)
cv.destroyAllwindows()
#height to 200 pixels
h,w,_=imgbgr.shape
w=w
h=200
dim=(h,w)
height_img=cv.resize(imgbgr,dim,interpolation=cv.INTER_AREA)
cv.imshow("original".imgbgr)
cv.waitkey(0)
cv.imshow("height image",height_img)
cv.waitkey(0)
cv.destroyAllwindows()
#heightandwidth for 200 pixels
h,w,_=imgbgr.shape
h=200
w=200
dim=(h,w)
hw_img=cv.resize(imgbgr,dim,interpolation=cv.INTER_AREA)
cv.imshow("original".imgbgr)
cv.waitkey(0)
cv.imshow("height and width image",hw_img)
cv.waitkey(0)
cv.destroyAllwindows()

"""### Task 4: Resize Using Scale Factors (fx, fy)
Scale up by 1.2 in both directions and down by 0.6. Use different interpolations (INTER_LINEAR, INTER_NEAREST) and compare quality.
"""

# Your code here
scale_up_x=1.2
scale_up_y=1.2
scale_down=0.6
# Experiment with interpolations
scaled_f_down=cv.resize(img,None,fx=scale_down,fy=scale_down,interpolation=cv.INTER_NEAREST)#blocky and pixlated
scaled_f_up=cv.resize(imgg,None,fx=scale_up_x,fy_scale_up_y,interpolation=cv.INTER_LINEAR)#smoother

"""### Task 5: Cropping an Image
Crop a region (e.g., [20:200, 50:200]) from the image. Display original and cropped.
"""

# Your code here
Cropped_img = img [20:200 , 50:200]
cv.imshow("Orignal", imgbgr)
cv.waitKey(0)
cv.imshow("Cropped img ", Cropped_img)
cv.waitKey(0)
cv.destroyAllWindows()

"""### Task 6: Advanced Cropping - Patch Image into Blocks
Divide the image into 4 equal blocks (2x2 grid) by cropping. Display each block separately and then stitch them back using NumPy concatenation to verify.
"""

# Your code here
# Calculate midpoints for height and width
height,width,_=imgbgr.shape
center=(width/2,height/2)
# Crop into top-left, top-right, bottom-left, bottom-right
top_left = img_rgb[0:mid_h, 0:mid_w]
top_right = img_rgb[0:mid_h, mid_w:w]
bottom_left = img_rgb[mid_h:h, 0:mid_w]
bottom_right = img_rgb[mid_h:h, mid_w:w]
# Display each
titles = ["Top Left", "Top Right", "Bottom Left", "Bottom Right"]
blocks = [top_left, top_right, bottom_left, bottom_right]

plt.figure(figsize=(8, 8))
for i in range(4):
    plt.subplot(2, 2, i+1)
    plt.imshow(blocks[i])
    plt.title(titles[i])
    plt.axis("off")
plt.show()
# Stitch back (use np.hstack and np.vstack)
top_row = np.hstack((top_left, top_right))
bottom_row = np.hstack((bottom_left, bottom_right))
stitched = np.vstack((top_row, bottom_row))

"""### Task 7: Rotating an Image
Rotate the image by 45°, 90°, and 180° using getRotationMatrix2D and warpAffine. Display all rotations.
"""

# Your code here
# Calculate center
height, width , _= imgbgr.shape
center = (width/2, height/2)
# For each angle: get matrix, warp, display
rotate_matrix = cv.getRotationMatrix2D(center=center, angle=45, scale=1)
rotate_matrix
rotated_image = cv.warpAffine(src=imgbgr, M=rotate_matrix, dsize=(width, height))
print(img.shape)
print(rotated_image.shape)
cv.imshow("Orignal", imgbgr)
cv.waitKey(0)
cv.imshow("Rotated image 45 ", rotated_image)
cv.waitKey(0)
cv.destroyAllWindows()
rotate_matrix_90 = cv.getRotationMatrix2D(center=center, angle = 90, scale=1)
rotate_matrix_180 = cv.getRotationMatrix2D(center=center, angle = 180, scale=1)
rotated_image_90 = cv.warpAffine(src=img, M=rotate_matrix_90, dsize=(width, height))
rotated_image_180 = cv.warpAffine(src=img, M=rotate_matrix_180, dsize=(width, height))
cv.imshow("Orignal", imgbgr)
cv.waitKey(0)
cv.imshow("Rotated image 45 ", rotated_image)
cv.waitKey(0)
cv.imshow("Rotated image 90 ", rotated_image_90)
cv.waitKey(0)
cv.imshow("Rotated image 180 ", rotated_image_180)
cv.waitKey(0)
cv.destroyAllWindows()





"""### Task 8: Rotate with Scaling
Rotate by 45° and scale by 0.5 in **one** operation. Compare with separate resize and rotate.
"""

# Your code here
height, width , _= imgbgr.shape
center = (width/2, height/2)
rotate_matrix = cv.getRotationMatrix2D(center=center, angle=45, scale=0.5)

scaled = cv.resize(img_rgb, None, fx=0.5, fy=0.5, interpolation=cv.INTER_LINEAR)


h2, w2, _ = scaled.shape
center2 = (w2 / 2, h2 / 2)
rotate_matrix2 = cv.getRotationMatrix2D(center=center2, angle=45, scale=1.0)  #rotation only
rotated_scaled_two = cv.warpAffine(scaled, rotate_matrix2, (w2, h2))

plt.figure(figsize=(12, 6)) #same as cv.imshow
plt.subplot(1, 3, 1)
plt.imshow(img_rgb)
plt.title("Original")
plt.axis("off")
plt.subplot(1, 3, 2)
plt.imshow(rotated_scaled_one)
plt.title("One Operation (Rotate+Scale)")
plt.axis("off")
plt.subplot(1, 3, 3)
plt.imshow(rotated_scaled_two)
plt.title("Two Operations (Resize→Rotate)")
plt.axis("off")
plt.tight_layout()
plt.show()

"""## Session 2: Image Acquisition, Formats, Color Spaces, Enhancement, and Filtering

### Task 9: Read Image in Different Color Spaces
Read an image in BGR, convert to RGB (for Matplotlib), HSV, LAB and Grayscale. Display all.
"""

# Your code here
# Read in BGR
imgbgr=cv.imread(filename,-1)
# Use cv.cvtColor()
mat_image = cv.cvtColor(imgbgr , cv.COLOR_BGR2RGB)
plt.imshow(mat_image)
plt.title("BGR image")
plt.show()
plt.imshow(mat_image)
plt.title("RGB image")
plt.show()

"""### Task 10: Image Sharpening
Apply cv2.blur() with a 5x5 kernel, then use cv2.filter2D() with sharpening kernels of varying strengths (e.g., [[0, -1, 0], [-1, 5, -1], [0, -1, 0]] and [[0, -2, 0], [-2, 9, -2], [0, -2, 0]]).
Compare between original and sharpened image after blurring.
"""

# Your code here
# Use cv2.blur
blurred_img = cv.blur(imgbgr, (5, 5)) #5*5 kernel
# Define sharpen kernel, use cv.filter2D()
kernel1 = np.array([[0, -1, 0],
                    [-1, 5, -1],
                    [0, -1, 0]], dtype=np.float32)

kernel2 = np.array([[0, -2, 0],
                    [-2, 9, -2],
                    [0, -2, 0]], dtype=np.float32)

# Step 3: Apply sharpening
sharpened1 = cv.filter2D(blurred, -1, kernel1)
sharpened2 = cv.filter2D(blurred, -1, kernel2)

# Step 4: Compare using pair_plot (BGR -> RGB with [:,:,::-1])
pair_plot(
    blurred[:, :, ::-1],
    sharpened1[:, :, ::-1],
    title1="Blurred (5x5 Average Filter)",
    title2="Sharpened (Kernel [[0,-1,0], [-1,5,-1], [0,-1,0]])"
)

pair_plot(
    blurred[:, :, ::-1],
    sharpened2[:, :, ::-1],
    title1="Blurred (5x5 Average Filter)",
    title2="Sharpened (Kernel [[0,-2,0], [-2,9,-2], [0,-2,0]])"
)


"""### Task 11: Add Salt and Pepper Noise to Image
Implement a function to add salt and pepper noise to an image. Control noise density (e.g., 0.05).
"""

# Your code here
def add_salt_pepper_noise(image, density=0.05):
    # Implement using random pixels set to 0 or 255
    img = cv.imread('', cv.IMREAD_GRAYSCALE)
plt.figure(), plt.imshow(img, cmap="gray", vmin=0, vmax=255), plt.title('Original Image')
pass
from skimage.util import random_noise
noisyImg = random_noise(img, mode="s&p",amount=0.05)
noisyImg = np.array(255*noisyImg, dtype="uint8")
plt.figure(), plt.imshow(noisyImg, cmap="gray", vmin=0, vmax=255), plt.title('Noisy Image')

outMed = cv.medianBlur(noisyImg, 5)
plt.figure(), plt.imshow(outMed, cmap="gray", vmin=0, vmax=255), plt.title('Median Filter')
    

""" 

# Your code here""

###
# 
#  Task 13: Implement Adaptive Median Filter
Write a custom function for adaptive median filtering. It should dynamically increase window size until noise is removed or max size is reached. Apply to a noisy image and compare with standard median.
"""

# Your code here
def adaptive_median_filter(image, max_size=7):
    # Implement logic: for each pixel, start with small window, increase if needed
    pass
    if len(image.shape) == 3:
        gray = cv.cvtColor(image, cv.COLOR_BGR2GRAY)
    else:
        gray = image.copy()

    padded_img = np.pad(gray, max_size // 2, mode='edge')  # padding
    filtered_img = np.zeros_like(gray)

    rows, cols = gray.shape

    # For each pixel
    for i in range(rows):
        for j in range(cols):
            window_size = 3  # start with 3x3 window

            while True:
                half = window_size // 2
                window = padded_img[i:i + window_size, j:j + window_size]

                z_min = np.min(window)
                z_max = np.max(window)
                z_med = np.median(window)
                z_xy = padded_img[i + half, j + half]

                A1 = z_med - z_min
                A2 = z_med - z_max

                if A1 > 0 and A2 < 0:
                    # Go to stage B
                    B1 = z_xy - z_min
                    B2 = z_xy - z_max
                    if B1 > 0 and B2 < 0:
                        filtered_img[i, j] = z_xy
                    else:
                        filtered_img[i, j] = z_med
                    break
                else:
                    window_size += 2
                    if window_size > max_size:
                        filtered_img[i, j] = z_med
                        break

    return filtered_img


# Test on noisy image
if __name__ == "__main__":
    img = cv.imread("noisy_image.jpg")

    # Apply standard median filter
    median_filtered = cv.medianBlur(cv.cvtColor(img, cv.COLOR_BGR2GRAY), 3)

    # Apply adaptive median filter
    adaptive_filtered = adaptive_median_filter(img, max_size=7)

    # Show results
    cv.imshow("Original", img)
    cv.imshow("Median Filter", median_filtered)
    cv.imshow("Adaptive Median Filter", adaptive_filtered)
    cv.waitKey(0)
    cv.destroyAllWindows() 


"""### Task 14: Implement Bilateral Filter Function
Write a Python function to perform bilateral filtering on an image. Use Gaussian weights for both spatial and intensity. Parameters: diameter, sigma_color, sigma_space. Compare with cv.bilateralFilter().
"""

# Your code here
def custom_bilateral_filter(image, diameter, sigma_color, sigma_space):
    # Implement using nested loops or vectorized (efficiently)
    # For each pixel, compute weighted sum based on distance and intensity diff
    pass
    if len(image.shape) == 3:
        gray = cv.cvtColor(image, cv.COLOR_BGR2GRAY)
    else:
        gray = image.copy()

    half = diameter // 2
    padded = np.pad(gray, half, mode='reflect')
    filtered = np.zeros_like(gray, dtype=np.float32)

    rows, cols = gray.shape

    x, y = np.mgrid[-half:half+1, -half:half+1]
    spatial_gauss = np.exp(-(x**2 + y**2) / (2 * sigma_space**2))

    for i in range(rows):
        for j in range(cols):
    
            region = padded[i:i+diameter, j:j+diameter]

            
            intensity_diff = region - gray[i, j]
            range_gauss = np.exp(-(intensity_diff**2) / (2 * sigma_color**2))

           
            weights = spatial_gauss * range_gauss
            weights /= np.sum(weights)  # normalize

            # Weighted sum
            filtered[i, j] = np.sum(region * weights)

    return filtered.astype(np.uint8)
if __name__ == "__main__":
    img = cv.imread("noisy_image.jpg")

    custom_result = custom_bilateral_filter(img, diameter=9, sigma_color=50, sigma_space=50)
    opencv_result = cv.bilateralFilter(cv.cvtColor(img, cv.COLOR_BGR2GRAY), 9, 50, 50)

    cv.imshow("Original", img)
    cv.imshow("Custom Bilateral", custom_result)
    cv.imshow("OpenCV Bilateral", opencv_result)
    cv.waitKey(0)
    cv.destroyAllWindows()


"""### [BONUS] Task 15: Comprehensive Camera Task
Combine: Live camera feed -> grayscale -> add noise -> remove with median -> sharpen. Display all stages in separate windows.
"""

# To read video from camera example:

camera_id = 0
delay = 400
window_name = 'frame'

cap = cv.VideoCapture(camera_id)

if not cap.isOpened():
    sys.exit()

while cap.isOpened():
    ret, frame = cap.read()
    if not ret:
        break

    cv.imshow(window_name, frame)
    if cv.waitKey(delay) & 0xFF == ord('q'):
        break

cap.release()
cv.destroyWindow(window_name)


# Your code here

"""### [BONUS]Task 16: Comprehensive Video Task
Similar to Task 18 but for a video file. Save the final processed video.
"""

# Your code here

"""### Task 17: Performance Comparison
Time the execution of standard median vs adaptive median on a large noisy image. Discuss when adaptive median filter is better.
"""

import time

import cv2 as cv
import numpy as np
import time

# --- Reuse adaptive median filter function (from Task 13) ---
def adaptive_median_filter(image, max_size=7):
    if len(image.shape) == 3:
        gray = cv.cvtColor(image, cv.COLOR_BGR2GRAY)
    else:
        gray = image.copy()

    padded_img = np.pad(gray, max_size // 2, mode='edge')
    filtered_img = np.zeros_like(gray)
    rows, cols = gray.shape

    for i in range(rows):
        for j in range(cols):
            window_size = 3
            while True:
                half = window_size // 2
                window = padded_img[i:i + window_size, j:j + window_size]
                z_min = np.min(window)
                z_max = np.max(window)
                z_med = np.median(window)
                z_xy = padded_img[i + half, j + half]

                A1 = z_med - z_min
                A2 = z_med - z_max

                if A1 > 0 and A2 < 0:
                    B1 = z_xy - z_min
                    B2 = z_xy - z_max
                    if B1 > 0 and B2 < 0:
                        filtered_img[i, j] = z_xy
                    else:
                        filtered_img[i, j] = z_med
                    break
                else:
                    window_size += 2
                    if window_size > max_size:
                        filtered_img[i, j] = z_med
                        break

    return filtered_img


np.random.seed(0)
image = np.random.randint(0, 256, (512, 512), dtype=np.uint8)  # large noisy grayscale



# Your code here
# Use time.time() to measure
start = time.time()
median_result = cv.medianBlur(image, 3)
t_median = time.time() - start
print(f"Standard Median Filter Time: {t_median:.4f} sec")


start = time.time()
adaptive_result = adaptive_median_filter(image, max_size=7)
t_adaptive = time.time() - start
print(f"Adaptive Median Filter Time: {t_adaptive:.4f} sec")


cv.imshow("Original", image)
cv.imshow("Standard Median", median_result)
cv.imshow("Adaptive Median", adaptive_result)
cv.waitKey(0)
cv.destroyAllWindows()
